<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VecTor 3D - Spatial Matrix Visualizer</title>
    <style>
        :root {
            --bg-color: #ffffff;
            --card-color: #f3f4f6;
            --text-color: #1f2937;
            --border-color: #e5e7eb;
            --input-bg: #ffffff;
            --grid-line: #e5e7eb;
            --axis-line: #9ca3af;
            
            --color-i: #ef4444; /* Red */
            --color-j: #22c55e; /* Green */
            --color-k: #3b82f6; /* Blue */
            --color-a: #f59e0b; /* Orange/Amber */
            --accent: #6366f1;
        }

        [data-theme="dark"] {
            --bg-color: #111827;
            --card-color: #1f2937;
            --text-color: #f3f4f6;
            --border-color: #374151;
            --input-bg: #374151;
            --grid-line: #374151;
            --axis-line: #4b5563;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; font-family: 'Segoe UI', sans-serif; transition: background-color 0.3s, color 0.3s; }
        
        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            height: 100vh;
            display: flex;
            overflow: hidden;
        }

        /* Sidebar */
        .sidebar {
            width: 400px;
            background-color: var(--card-color);
            padding: 20px;
            display: flex;
            flex-direction: column;
            border-right: 1px solid var(--border-color);
            z-index: 10;
            box-shadow: 2px 0 10px rgba(0,0,0,0.05);
            overflow-y: auto;
        }

        h1 { font-size: 22px; margin-bottom: 20px; font-weight: 700; }
        h2 { font-size: 15px; margin-bottom: 10px; font-weight: 600; opacity: 0.9; }

        .section {
            background-color: var(--bg-color);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
        }

        /* Matrix 3x3 Styling */
        .matrix-container {
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            padding: 10px;
        }
        
        .matrix-grid {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr; /* 3 Columns */
            gap: 8px;
        }

        .vector-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 8px;
        }

        .bracket-border {
            position: absolute;
            top: 0; bottom: 0; left: 0; right: 0;
            border: 2px solid #d1d5db;
            border-top: none;
            border-bottom: none;
            width: 100%;
            pointer-events: none;
        }
        .bracket-border::before, .bracket-border::after {
            content: ''; position: absolute; width: 10px; height: 2px; background: #d1d5db;
        }
        .bracket-border::before { top: 0; left: 0; }
        .bracket-border::after { bottom: 0; left: 0; }
        .bracket-border-right::before { top: 0; right: 0; left: auto; }
        .bracket-border-right::after { bottom: 0; right: 0; left: auto; }

        /* Input Fields */
        .input-wrapper {
            position: relative;
        }
        
        /* Tiny label inside input area */
        .tiny-label {
            position: absolute;
            top: 2px;
            left: 4px;
            font-size: 9px;
            font-weight: bold;
            opacity: 0.7;
            pointer-events: none;
        }

        input[type="number"] {
            width: 100%;
            padding: 12px 4px 4px 4px; /* Space for tiny label */
            background-color: var(--input-bg);
            border: 1px solid var(--border-color);
            color: var(--text-color);
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            font-size: 15px;
            text-align: center;
            outline: none;
        }
        input[type="number"]:focus { border-color: var(--accent); }

        /* Canvas Area */
        .main-content {
            flex: 1;
            position: relative;
            display: flex;
            flex-direction: column;
        }

        canvas {
            flex: 1;
            cursor: move; /* 3D rotate cursor */
            display: block;
        }

        /* View Toggle Button */
        .view-toggle {
            position: absolute;
            top: 20px;
            right: 20px;
            background-color: var(--card-color);
            color: var(--text-color);
            border: 1px solid var(--border-color);
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            z-index: 50;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .view-toggle:hover { transform: translateY(-1px); box-shadow: 0 6px 8px rgba(0,0,0,0.15); }
        .view-toggle span { display: inline-block; width: 8px; height: 8px; border-radius: 50%; }
        .dot-free { background-color: var(--color-a); }
        .dot-iso { background-color: var(--color-j); }

        /* Bottom Panel */
        .bottom-panel {
            height: 70px;
            background-color: var(--card-color);
            border-top: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 30px;
        }

        .info-labels {
            display: flex;
            gap: 20px;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            font-size: 13px;
        }

        .controls { display: flex; gap: 10px; }

        .btn-action {
            background-color: var(--accent);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            font-weight: bold;
            cursor: pointer;
            font-size: 16px;
        }
        .btn-action:hover { opacity: 0.9; }
        .btn-action:disabled { background-color: var(--axis-line); cursor: not-allowed; }

        .theme-btn {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            background: var(--card-color);
            color: var(--text-color);
            padding: 8px;
            border-radius: 50%;
            border: 1px solid var(--border-color);
            cursor: pointer;
        }

        /* Helpers */
        .text-i { color: var(--color-i); }
        .text-j { color: var(--color-j); }
        .text-k { color: var(--color-k); }
        .text-a { color: var(--color-a); }

        @media (max-width: 900px) {
            body { flex-direction: column; overflow-y: auto; }
            .sidebar { width: 100%; order: 2; height: auto;}
            .main-content { height: 60vh; order: 1; }
        }
    </style>
</head>
<body>

    <!-- Theme Toggle -->
    <button class="theme-btn" id="themeBtn">ðŸŒ“</button>

    <!-- Sidebar -->
    <div class="sidebar">
        <h1>3D Transformations</h1>

        <!-- Matrix Section -->
        <div class="section">
            <h2>Matrix T (Basis Vectors)</h2>
            <div class="matrix-container">
                <div class="bracket-border"></div>
                <div class="bracket-border bracket-border-right">
                     <span style="position:absolute; width:10px; height:2px; background:#d1d5db; top:0; right:0;"></span>
                     <span style="position:absolute; width:10px; height:2px; background:#d1d5db; bottom:0; right:0;"></span>
                </div>
                
                <div class="matrix-grid">
                    <!-- Row X -->
                    <div class="input-wrapper"><span class="tiny-label text-i">iÂ·x</span><input type="number" id="ix" value="1.0" step="0.1"></div>
                    <div class="input-wrapper"><span class="tiny-label text-j">jÂ·x</span><input type="number" id="jx" value="0.0" step="0.1"></div>
                    <div class="input-wrapper"><span class="tiny-label text-k">kÂ·x</span><input type="number" id="kx" value="0.0" step="0.1"></div>
                    
                    <!-- Row Y -->
                    <div class="input-wrapper"><span class="tiny-label text-i">iÂ·y</span><input type="number" id="iy" value="0.0" step="0.1"></div>
                    <div class="input-wrapper"><span class="tiny-label text-j">jÂ·y</span><input type="number" id="jy" value="1.0" step="0.1"></div>
                    <div class="input-wrapper"><span class="tiny-label text-k">kÂ·y</span><input type="number" id="ky" value="0.0" step="0.1"></div>

                    <!-- Row Z -->
                    <div class="input-wrapper"><span class="tiny-label text-i">iÂ·z</span><input type="number" id="iz" value="0.0" step="0.1"></div>
                    <div class="input-wrapper"><span class="tiny-label text-j">jÂ·z</span><input type="number" id="jz" value="0.0" step="0.1"></div>
                    <div class="input-wrapper"><span class="tiny-label text-k">kÂ·z</span><input type="number" id="kz" value="1.0" step="0.1"></div>
                </div>
            </div>
        </div>

        <!-- Vector Section -->
        <div class="section">
            <h2>Input Vector (a)</h2>
            <div style="display: flex; align-items: center; justify-content: center; gap: 10px;">
                <span style="font-family: serif; font-style: italic; font-size: 18px;">a = </span>
                <div class="matrix-container">
                    <div class="bracket-border"></div>
                    <div class="bracket-border bracket-border-right">
                        <span style="position:absolute; width:10px; height:2px; background:#d1d5db; top:0; right:0;"></span>
                        <span style="position:absolute; width:10px; height:2px; background:#d1d5db; bottom:0; right:0;"></span>
                   </div>
                    <div class="vector-grid">
                        <div class="input-wrapper"><span class="tiny-label text-a">x</span><input type="number" id="ax" value="1.0" step="0.1"></div>
                        <div class="input-wrapper"><span class="tiny-label text-a">y</span><input type="number" id="ay" value="1.0" step="0.1"></div>
                        <div class="input-wrapper"><span class="tiny-label text-a">z</span><input type="number" id="az" value="1.0" step="0.1"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Main Canvas Area -->
    <div class="main-content">
        <!-- Smart Toggle Button -->
        <button class="view-toggle" id="viewToggle">
            <span class="dot-free" id="viewDot"></span> <span id="viewText">Free 3D</span>
        </button>

        <canvas id="canvas"></canvas>
        
        <div class="bottom-panel">
            <div class="info-labels">
                <span id="lblDeterminant">Det: 1.00</span>
                <span style="border-left: 1px solid var(--border-color); margin: 0 5px;"></span>
                <span id="lblTransformed">T(a) = (1.0, 1.0, 1.0)</span>
            </div>
            <div class="controls">
                <button class="btn-action" id="btnPlay">â–¶ Play</button>
                <button class="btn-action" id="btnStop" disabled>â–  Stop</button>
            </div>
        </div>
    </div>

    <script>
        // --- State Management ---
        const state = {
            // Matrix (Basis Vectors)
            ix: 1.0, iy: 0.0, iz: 0.0,
            jx: 0.0, jy: 1.0, jz: 0.0,
            kx: 0.0, ky: 0.0, kz: 1.0,
            // Input Vector
            ax: 1.0, ay: 1.0, az: 1.0,
            
            // View / Camera
            scale: 80,
            yaw: -0.6,
            pitch: 0.4,
            isIsometric: false,
            
            // UI
            isDark: false,
            isDragging: false,
            lastMx: 0, lastMy: 0,
            
            // Animation (Transformation)
            animating: false,
            animProgress: 0,
            animDirection: 0.015,
            snap: {}, // Snapshot for reset

            // View Animation
            viewAnimating: false
        };

        // Constants
        const ISO_YAW = -Math.PI / 4; // -45 deg
        const ISO_PITCH = Math.atan(1 / Math.sqrt(2)); // ~35.26 deg

        // DOM
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const inputIds = ['ix','iy','iz','jx','jy','jz','kx','ky','kz','ax','ay','az'];
        const inputs = {};
        inputIds.forEach(id => inputs[id] = document.getElementById(id));
        
        const viewToggleBtn = document.getElementById('viewToggle');
        const viewText = document.getElementById('viewText');
        const viewDot = document.getElementById('viewDot');
        
        const themeBtn = document.getElementById('themeBtn');
        const lblDet = document.getElementById('lblDeterminant');
        const lblTrans = document.getElementById('lblTransformed');
        const btnPlay = document.getElementById('btnPlay');
        const btnStop = document.getElementById('btnStop');

        // --- Init ---
        function init() {
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            // Input Bindings
            inputIds.forEach(id => {
                inputs[id].addEventListener('input', (e) => {
                    const val = parseFloat(e.target.value);
                    if (!isNaN(val)) {
                        state[id] = val;
                        updateInfo();
                        draw();
                    }
                });
            });

            // Theme
            if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) toggleTheme();
            themeBtn.addEventListener('click', toggleTheme);

            // Canvas Interaction
            canvas.addEventListener('mousedown', onMouseDown);
            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('mouseup', onMouseUp);
            
            // Smart View Toggle
            viewToggleBtn.addEventListener('click', toggleSmartView);

            // Animation Buttons
            btnPlay.addEventListener('click', startAnimation);
            btnStop.addEventListener('click', stopAnimation);

            draw();
        }

        // --- 3D Projection Logic ---

        function project(x, y, z) {
            // Rotate Yaw (around Y axis in 3D, but standard math usually rotates around Z. 
            // Here we define Y as UP. So Yaw rotates X and Z).
            // Formula adapted for Y-Up right-handed system
            
            const cy = Math.cos(state.yaw);
            const sy = Math.sin(state.yaw);
            const cp = Math.cos(state.pitch);
            const sp = Math.sin(state.pitch);

            // 1. Yaw (Rotation around Y-axis)
            const x1 = x * cy - z * sy;
            const z1 = x * sy + z * cy;
            const y1 = y;

            // 2. Pitch (Rotation around X-axis)
            const y2 = y1 * cp - z1 * sp;
            const z2 = y1 * sp + z1 * cp;

            // 3. Orthographic Projection
            const cx = canvas.width / 2;
            const cy_screen = canvas.height / 2;
            
            return {
                x: cx + x1 * state.scale,
                y: cy_screen - y2 * state.scale, // Y is up, screen Y is down
                depth: z2 // Used for Z-sorting if needed
            };
        }

        function getTransformedPoint(u, v, w) {
            return {
                x: u * state.ix + v * state.jx + w * state.kx,
                y: u * state.iy + v * state.jy + w * state.ky,
                z: u * state.iz + v * state.jz + w * state.kz
            };
        }

        // --- Drawing ---

        function draw() {
            const w = canvas.width;
            const h = canvas.height;
            ctx.clearRect(0, 0, w, h);

            // Styles
            const style = getComputedStyle(document.body);
            const colGrid = state.isDark ? '#374151' : '#e5e7eb';
            const colAxis = state.isDark ? '#4b5563' : '#9ca3af';
            const colI = style.getPropertyValue('--color-i').trim();
            const colJ = style.getPropertyValue('--color-j').trim();
            const colK = style.getPropertyValue('--color-k').trim();
            const colA = style.getPropertyValue('--color-a').trim();

            // 1. Draw Grid (Projected planes)
            ctx.lineWidth = 1;
            drawGrid(colGrid, colAxis);

            // 2. Draw Basis Vectors
            // Origin
            const origin = project(0, 0, 0);

            drawArrow(0,0,0, state.ix, state.iy, state.iz, colI, "i");
            drawArrow(0,0,0, state.jx, state.jy, state.jz, colJ, "j");
            drawArrow(0,0,0, state.kx, state.ky, state.kz, colK, "k");

            // 3. Draw Result Vector
            const res = getTransformedPoint(state.ax, state.ay, state.az);
            
            // Draw "Shadow" line to floor (Z=0 plane) if Z is significant
            if (Math.abs(res.z) > 0.05) {
                const floorPt = project(res.x, res.y, 0);
                const tip = project(res.x, res.y, res.z);
                ctx.beginPath();
                ctx.setLineDash([4, 4]);
                ctx.strokeStyle = colA + "66"; // Transparent
                ctx.moveTo(tip.x, tip.y);
                ctx.lineTo(floorPt.x, floorPt.y);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Dot on floor
                ctx.fillStyle = colA + "66";
                ctx.beginPath();
                ctx.arc(floorPt.x, floorPt.y, 3, 0, Math.PI*2);
                ctx.fill();
            }

            drawArrow(0,0,0, res.x, res.y, res.z, colA, "a");

            // Center Dot
            ctx.fillStyle = state.isDark ? '#fff' : '#333';
            ctx.beginPath();
            ctx.arc(origin.x, origin.y, 3, 0, Math.PI*2);
            ctx.fill();
        }

        function drawGrid(color, axisColor) {
            const range = 4;
            // Draw transformed grid lines on the "floor" defined by i and k (roughly) 
            // or just a standard 3D grid transformed.
            // Let's draw lines parallel to the main axes in the transformed space
            
            ctx.lineWidth = 1;

            // Helper to draw a segment in 3D
            const line3D = (p1, p2, col) => {
                const s1 = project(p1.x, p1.y, p1.z);
                const s2 = project(p2.x, p2.y, p2.z);
                ctx.beginPath();
                ctx.strokeStyle = col;
                ctx.moveTo(s1.x, s1.y);
                ctx.lineTo(s2.x, s2.y);
                ctx.stroke();
            };

            for (let i = -range; i <= range; i++) {
                const c = (i === 0) ? axisColor : color;
                // Lines along X axis (varying Z)
                // Start: (-range, 0, i) -> End: (range, 0, i)
                // BUT we apply the T matrix to these grid points!
                
                // Actually, standard visualizers usually show the grid of the input space transformed.
                // Let's draw the grid on the XZ plane (y=0) transformed.
                
                // Line varying X
                let pStart = getTransformedPoint(-range, 0, i);
                let pEnd = getTransformedPoint(range, 0, i);
                line3D(pStart, pEnd, c);

                // Line varying Z
                pStart = getTransformedPoint(i, 0, -range);
                pEnd = getTransformedPoint(i, 0, range);
                line3D(pStart, pEnd, c);
            }
        }

        function drawArrow(x1, y1, z1, x2, y2, z2, color, label) {
            const start = project(x1, y1, z1);
            const end = project(x2, y2, z2);

            // Line
            ctx.beginPath();
            ctx.moveTo(start.x, start.y);
            ctx.lineTo(end.x, end.y);
            ctx.strokeStyle = color;
            ctx.lineWidth = 3;
            ctx.lineCap = 'round';
            ctx.stroke();

            // Arrowhead
            const angle = Math.atan2(end.y - start.y, end.x - start.x);
            const headLen = 10;
            ctx.beginPath();
            ctx.moveTo(end.x, end.y);
            ctx.lineTo(end.x - headLen * Math.cos(angle - Math.PI / 6), end.y - headLen * Math.sin(angle - Math.PI / 6));
            ctx.lineTo(end.x - headLen * Math.cos(angle + Math.PI / 6), end.y - headLen * Math.sin(angle + Math.PI / 6));
            ctx.fillStyle = color;
            ctx.fill();

            // Label
            ctx.fillStyle = color;
            ctx.font = "bold 14px sans-serif";
            ctx.fillText(label, end.x + 10, end.y);
        }

        // --- Interaction & Smart View ---

        function toggleSmartView() {
            state.isIsometric = !state.isIsometric;
            if (state.isIsometric) {
                // Animate to Iso
                updateViewButton("Isometric (Locked)", "dot-iso");
                animateCameraTo(ISO_YAW, ISO_PITCH);
            } else {
                updateViewButton("Free 3D", "dot-free");
            }
        }

        function updateViewButton(text, dotClass) {
            viewText.textContent = text;
            viewDot.className = "";
            viewDot.classList.add(dotClass);
        }

        function animateCameraTo(targetYaw, targetPitch) {
            state.viewAnimating = true;
            const startYaw = state.yaw;
            const startPitch = state.pitch;
            let progress = 0;

            function step() {
                if (!state.viewAnimating) return; // Interrupted
                progress += 0.05;
                if (progress >= 1) {
                    state.yaw = targetYaw;
                    state.pitch = targetPitch;
                    state.viewAnimating = false;
                    draw();
                    return;
                }
                
                // Ease Out Quad
                const t = progress * (2 - progress);
                state.yaw = startYaw + (targetYaw - startYaw) * t;
                state.pitch = startPitch + (targetPitch - startPitch) * t;
                draw();
                requestAnimationFrame(step);
            }
            requestAnimationFrame(step);
        }

        function onMouseDown(e) {
            state.isDragging = true;
            state.lastMx = e.clientX;
            state.lastMy = e.clientY;
        }

        function onMouseMove(e) {
            if (!state.isDragging) return;

            // SMART UNLOCK:
            // If dragging happens while in Isometric mode, unlock immediately
            if (state.isIsometric) {
                state.isIsometric = false;
                state.viewAnimating = false; // Stop any tweening
                updateViewButton("Free 3D", "dot-free");
            }

            const dx = e.clientX - state.lastMx;
            const dy = e.clientY - state.lastMy;
            
            state.yaw += dx * 0.01;
            state.pitch += dy * 0.01;
            
            // Clamp pitch to avoid flipping
            state.pitch = Math.max(-Math.PI/2 + 0.1, Math.min(Math.PI/2 - 0.1, state.pitch));

            state.lastMx = e.clientX;
            state.lastMy = e.clientY;
            draw();
        }

        function onMouseUp() {
            state.isDragging = false;
        }

        // --- Helpers ---

        function resizeCanvas() {
            const parent = canvas.parentElement;
            canvas.width = parent.clientWidth;
            canvas.height = parent.clientHeight - 70;
            draw();
        }

        function toggleTheme() {
            state.isDark = !state.isDark;
            document.body.setAttribute('data-theme', state.isDark ? 'dark' : 'light');
            themeBtn.textContent = state.isDark ? 'â˜€ï¸' : 'ðŸŒ“';
            draw();
        }

        function updateInfo() {
            // Det(3x3)
            // a(ei âˆ’ fh) âˆ’ b(di âˆ’ fg) + c(dh âˆ’ eg)
            // ix(jy*kz - jz*ky) ...
            const det = 
                state.ix * (state.jy * state.kz - state.jz * state.ky) -
                state.iy * (state.jx * state.kz - state.jz * state.kx) +
                state.iz * (state.jx * state.ky - state.jy * state.kx);
            
            const res = getTransformedPoint(state.ax, state.ay, state.az);

            lblDet.textContent = `Det: ${det.toFixed(2)}`;
            lblTrans.textContent = `T(a) = (${res.x.toFixed(1)}, ${res.y.toFixed(1)}, ${res.z.toFixed(1)})`;
        }

        function lerp(s, e, t) { return s + (e - s) * t; }

        // --- Matrix Animation ---
        
        function startAnimation() {
            if (state.animating) return;
            // Snapshot current matrix
            state.snap = { 
                ix: state.ix, iy: state.iy, iz: state.iz,
                jx: state.jx, jy: state.jy, jz: state.jz,
                kx: state.kx, ky: state.ky, kz: state.kz
            };
            
            state.animating = true;
            state.animProgress = 0;
            state.animDirection = 0.015;
            
            setInputsDisabled(true);
            btnPlay.disabled = true;
            btnStop.disabled = false;
            
            animateFrame();
        }

        function stopAnimation() {
            state.animating = false;
            // Restore
            Object.keys(state.snap).forEach(k => state[k] = state.snap[k]);
            updateUIFields();
            updateInfo();
            draw();
            
            setInputsDisabled(false);
            btnPlay.disabled = false;
            btnStop.disabled = true;
        }

        function animateFrame() {
            if (!state.animating) return;

            state.animProgress += state.animDirection;
            if (state.animProgress >= 1.0) {
                state.animProgress = 1.0;
                state.animDirection = -0.01;
            } else if (state.animProgress <= 0.0) {
                state.animProgress = 0.0;
                state.animDirection = 0.01;
            }

            // Ease
            const t = state.animProgress * state.animProgress * (3 - 2 * state.animProgress);

            // Interpolate to Identity
            // Identity: i(1,0,0), j(0,1,0), k(0,0,1)
            state.ix = lerp(state.snap.ix, 1, t);
            state.iy = lerp(state.snap.iy, 0, t);
            state.iz = lerp(state.snap.iz, 0, t);

            state.jx = lerp(state.snap.jx, 0, t);
            state.jy = lerp(state.snap.jy, 1, t);
            state.jz = lerp(state.snap.jz, 0, t);

            state.kx = lerp(state.snap.kx, 0, t);
            state.ky = lerp(state.snap.ky, 0, t);
            state.kz = lerp(state.snap.kz, 1, t);

            updateUIFields();
            updateInfo();
            draw();

            requestAnimationFrame(animateFrame);
        }

        function updateUIFields() {
            inputIds.forEach(id => {
                if(inputs[id] !== document.activeElement) { // Don't update if user typing
                   inputs[id].value = parseFloat(state[id]).toFixed(2);
                }
            });
        }

        function setInputsDisabled(val) {
            inputIds.forEach(id => inputs[id].disabled = val);
        }

        // Run
        init();

    </script>
</body>
</html>
